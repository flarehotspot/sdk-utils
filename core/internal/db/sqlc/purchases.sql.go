// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: purchases.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPurchase = `-- name: CreatePurchase :one
INSERT INTO purchases (
  device_id, sku, name, description, 
  price, any_price, callback_plugin, 
  callback_vue_route_name
) 
VALUES 
  ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id
`

type CreatePurchaseParams struct {
	DeviceID             pgtype.UUID
	Sku                  string
	Name                 string
	Description          pgtype.Text
	Price                pgtype.Numeric
	AnyPrice             bool
	CallbackPlugin       string
	CallbackVueRouteName pgtype.Text
}

func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createPurchase,
		arg.DeviceID,
		arg.Sku,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.AnyPrice,
		arg.CallbackPlugin,
		arg.CallbackVueRouteName,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const findPending = `-- name: FindPending :one
SELECT 
  id, 
  device_id, 
  sku, 
  name, 
  description, 
  price, 
  any_price, 
  callback_plugin, 
  callback_vue_route_name, 
  wallet_debit, 
  wallet_tx_id, 
  confirmed_at, 
  cancelled_at, 
  cancelled_reason, 
  created_at 
FROM 
  purchases 
WHERE 
  confirmed_at IS NULL 
  AND cancelled_at IS NULL 
  AND device_id = $1 
LIMIT 
  1
`

func (q *Queries) FindPending(ctx context.Context, deviceID pgtype.UUID) (Purchase, error) {
	row := q.db.QueryRow(ctx, findPending, deviceID)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.AnyPrice,
		&i.CallbackPlugin,
		&i.CallbackVueRouteName,
		&i.WalletDebit,
		&i.WalletTxID,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CreatedAt,
	)
	return i, err
}

const findPurchase = `-- name: FindPurchase :one
SELECT 
  id, 
  device_id, 
  sku, 
  name, 
  description, 
  price, 
  any_price, 
  callback_plugin, 
  callback_vue_route_name, 
  wallet_debit, 
  wallet_tx_id, 
  confirmed_at, 
  cancelled_at, 
  cancelled_reason, 
  created_at 
FROM 
  purchases 
WHERE 
  id = $1 
LIMIT 
  1
`

func (q *Queries) FindPurchase(ctx context.Context, id pgtype.UUID) (Purchase, error) {
	row := q.db.QueryRow(ctx, findPurchase, id)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.AnyPrice,
		&i.CallbackPlugin,
		&i.CallbackVueRouteName,
		&i.WalletDebit,
		&i.WalletTxID,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CreatedAt,
	)
	return i, err
}

const findPurchaseByDeviceId = `-- name: FindPurchaseByDeviceId :one
SELECT 
  id, 
  device_id, 
  sku, 
  name, 
  description, 
  price, 
  any_price, 
  callback_plugin, 
  callback_vue_route_name, 
  wallet_debit, 
  wallet_tx_id, 
  confirmed_at, 
  cancelled_at, 
  cancelled_reason, 
  created_at 
FROM 
  purchases 
WHERE 
  device_id = $1 
LIMIT 
  1
`

func (q *Queries) FindPurchaseByDeviceId(ctx context.Context, deviceID pgtype.UUID) (Purchase, error) {
	row := q.db.QueryRow(ctx, findPurchaseByDeviceId, deviceID)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Sku,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.AnyPrice,
		&i.CallbackPlugin,
		&i.CallbackVueRouteName,
		&i.WalletDebit,
		&i.WalletTxID,
		&i.ConfirmedAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CreatedAt,
	)
	return i, err
}

const updatePurchase = `-- name: UpdatePurchase :exec
UPDATE 
  purchases 
SET 
  wallet_debit = $1, 
  wallet_tx_id = $2, 
  cancelled_at = $3, 
  confirmed_at = $4, 
  cancelled_reason = $5 
WHERE 
  id = $6
`

type UpdatePurchaseParams struct {
	WalletDebit     pgtype.Numeric
	WalletTxID      pgtype.UUID
	CancelledAt     pgtype.Timestamp
	ConfirmedAt     pgtype.Timestamp
	CancelledReason pgtype.Text
	ID              pgtype.UUID
}

func (q *Queries) UpdatePurchase(ctx context.Context, arg UpdatePurchaseParams) error {
	_, err := q.db.Exec(ctx, updatePurchase,
		arg.WalletDebit,
		arg.WalletTxID,
		arg.CancelledAt,
		arg.ConfirmedAt,
		arg.CancelledReason,
		arg.ID,
	)
	return err
}
